# Chain Left Documentation

## TL;DR

chainLeft is a tiny, powerful building block for expression parsing.

`chainLeft(term, op, makeNode)` parses **left‑associative operator chains** of
the form

```
term (op term)*
```

and **folds them left** into an AST:

```
(((a op b) op c) op d)
```

It gives you the same semantics as the classic grammar pattern:

```
E  → T E'
E' → op T E' | ε
```

but in a single, readable combinator that composes cleanly with other precedence
levels.


## chainLeft Pattern

`chainLeft(term, op, makeNode)` parses left-associative operator chains:

```
term (op term)*  =>  (((a op b) op c) op d)
```

Equivalent to classic grammar:
```
E  -> T E'
E' -> op T E' | ε
```

**Precedence ladder:**
1. primary (literals, identifiers, parenthesized)
2. postfix (calls, member access)
3. unary (`!`, `+`, `-`)
4. multiplicative (`*`, `/`, `%`)
5. additive (`+`, `-`)
6. comparison (`<`, `<=`, `>`, `>=`)
7. equality (`==`, `!=`)
8. logicalAnd (`&&`)
9. logicalOr (`||`)
10. conditional (`?:`) - if added




## The problem it solves

Arithmetic‑like languages have many **binary operators** with precedence and
associativity (e.g., `+`, `-`, `*`, `/`, `==`, `&&`, `||`).

A **top‑down (LL) parser** cannot handle left recursion directly, so the naïve
grammar:

```
E → E op T | T         // left‑recursive (rejects in LL)
```

must be transformed into a **right‑recursive / factored** form:

```
E  → T E'
E' → op T E' | ε       // classic E/E' expansion
```

That works, but it spreads the logic across extra nonterminals (E', T', …) and
bloats the grammar.

---

## Why `chainLeft` is nice with parser combinators

Parser combinators let you write **parsers as functions you compose**. The
pattern for a left‑assoc chain is always:

1. Parse a **head**: `term` (the lower‑precedence expression).
2. Parse **zero or more** pairs `(op term)`.
3. **Left‑fold** the list into an AST.

This maps directly to a tiny helper:

```shell
// Pseudo‑signature
chainLeft(
  term: Parser<Expr>,
  op: Parser<Op>,
  makeNode: (op: Op, left: Expr, right: Expr) => Expr
): Parser<Expr>
```

Internally, it’s just:

- sequencing: `term.then(op.then(term).optrep())`
- then a `.map(...)` that reduces `[head, op1, rhs1, op2, rhs2, ...]` into
  `(((head op1 rhs1) op2 rhs2) ...)`.

**Benefits**

- **No auxiliary nonterminals** (E', T', …).
- **One place** to implement left‑fold and attach source locations.
- **Precedence = layers of `chainLeft`**: build `multiplicative` over `unary`,
  then `additive` over `multiplicative`, etc.
- Pairs well with **`lazy`** for parentheses and recursion.

---

## Equivalence to the E/E' style (theory sketch)

Let `term` parse exactly `T`. Consider the language of strings generated by

```
E  → T E'
E' → op T E' | ε
```

Every successful derivation of `E` yields a sequence `T (op T)*` (i.e.,
`term (op term)*`). Conversely, any string of that shape fits the grammar by
inductively choosing `E' → op T E'` for each pair and ending with `ε`.

AST construction:

- The E/E' grammar typically builds nodes **as you return** from right
  recursion, but you immediately reconstruct them as a **left fold** to get left
  associativity.
- `chainLeft` skips the detour and **directly left‑folds** the parsed list.

So both produce the same AST structure and both are **O(n)** on flat chains.

---

## Building a precedence ladder

Write one `chainLeft` per precedence tier, from tightest to loosest:

```ts
const multiplicative = chainLeft(unary, mulOp, (op, l, r) => binary(op, l, r))
const additive = chainLeft(multiplicative, addOp, (op, l, r) =>
  binary(op, l, r),
)
const comparison = chainLeft(additive, cmpOp, (op, l, r) => binary(op, l, r))
const equality = chainLeft(comparison, eqOp, (op, l, r) => binary(op, l, r))
const logicalAnd = chainLeft(equality, andOp, (_, l, r) => logical('&&', l, r))
const logicalOr = chainLeft(logicalAnd, orOp, (_, l, r) => logical('||', l, r))
const expression = logicalOr
```

Add **parentheses** via a `primary` that includes a `(` expression `)` parser
using a **lazy** reference to `expression`.

---

## Associativity

- `chainLeft` encodes **left associativity** by construction.
- For **right‑associative** operators (e.g., exponent `^`, assignments), use a
  sibling helper `chainRight` (parse `term (op term)*` then **fold from
  right**).

---

## How it compares to other approaches

- **E/E' (factorized) grammars**: Same power and semantics; `chainLeft` is a
  **combinator realization** of that transformation, removing boilerplate.
- **Pratt / Top‑down operator precedence**: Excellent for large operator sets
  with mixed prefix/postfix and different binding powers. `chainLeft` is
  simpler; you typically use **a few `chainLeft` layers** instead of a full
  Pratt parser when your operators and fixities are straightforward.
- **Parser generators (LALR/GLR)**: They can accept left recursion directly, but
  in a combinator/LL setting you either factor (E/E') or use a helper like
  `chainLeft`.

---

## Complexity & performance

- Parsing `term (op term)*` is **linear** in the number of tokens matched.
- The left fold runs in **O(k)** where `k` is the number of operator
  applications. No extra recursion depth is required for long chains.

---

## Practical concerns & gotchas

- **Whitespace/lexing**: tokenizers should ensure `op` is unambiguous from unary
  operators; a separate unary stage avoids `-` ambiguity.
- **Unary vs binary**: parse **unary as a lower tier** (tighter precedence) and
  feed its result into `chainLeft`.
- **Parentheses**: require a forward/lazy reference so `primary` can include `(`
  expression `)`.
- **Error reporting**: centralizing the fold in `chainLeft` makes it easy to
  attach/merge `loc` spans from `left`, `op`, `right`.

---

## Minimal worked example (Masala‑style)

```ts
// number:  /[0-9]+/ → { type: 'literal-number', value }
// addOp :  '+' | '-'
// mulOp :  '*' | '/'
const primary = number.or(parenExpr) // parenExpr uses a lazy reference to expression
const multiplicative = chainLeft(primary, mulOp, (op, l, r) => ({
  type: 'binary',
  operator: op,
  left: l,
  right: r,
}))
const additive = chainLeft(multiplicative, addOp, (op, l, r) => ({
  type: 'binary',
  operator: op,
  left: l,
  right: r,
}))
const expression = additive
```

**Test idea**

- Input: `1+2*3-4*5+6`
- Expect: `(((1 + (2*3)) - (4*5)) + 6)` AST (left‑assoc at each level, `*`
  before `+/-`).

---

## When not to use `chainLeft`

- If your language has **dozens of operators** with mixed prefix/postfix, or
  requires **context‑sensitive** precedence tweaks → consider a **Pratt
  parser**.
- If you’re in a **GLR/LALR** world and already model left recursion directly →
  you may not need it.

---

## Takeaway

`chainLeft` is not magic—it’s the **combinator form of the standard LL
transformation** for left‑assoc binary operators. It keeps parser code small,
local, and easy to extend, while remaining faithful to the same theory that
underpins E/E' grammars and operator‑precedence parsing.

## More information on naming

In classic arithmetic grammars, a term is the level just below “expression” and
above “factor\*_/primary”—it’s the multiplicative layer (things combined with _,
/, %). Historically you see:

Expression (E): additive layer → + -

Term (T): multiplicative layer → \* / %

Factor / Primary (F): leaves → numbers, identifiers, parenthesized expressions

```shell
E  -> T (('+'|'-') T)*            # Expression
T  -> F (('*'|'/'|'%') F)*        # Term
F  -> NUMBER | IDENT | '(' E ')'  # Factor / Primary
```

In modern code, people often rename “term” to something clearer like
multiplicative (and “expression” to additive at that level). With unary, member
access, etc., a clean ladder is:

- primary: literals, identifiers, parenthesized (expr), pipe exprs
- postfix (optional): calls, member access. / [...]
- unary: prefix ! + -
- multiplicative: \* / % ← this is the classic term
- additive: + -
- comparison: < <= > >=
- equality: == !=

logicalAnd: &&

logicalOr: ||

conditional: ?: (if you add it)
