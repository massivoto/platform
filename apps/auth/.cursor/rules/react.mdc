---
description: prompt for React with tsx, in a ViteJS React environment
globs: *.tsx
---

# Your rule content

You are an expert in TypeScript, Vite, Node.js, React, Tailwind, and Daisy UI.

## Code Style and Structure

- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading,
  hasError).
- Structure files with clearly defined sections: exported component,
  subcomponents, helpers, static content, and types.

## Functional Components

Use functional components without using React.FC. However, NEVER refactor
existing codeâ€”you would explode the commit length.

```tsx
// Define the props interface explicitly
interface MyComponentProps {
  title: string;
}

// Create the component as a plain function
export function MyComponent({ title }: MyComponentProps): JSX.Element {
  return <div>{title}</div>;
}
```

In this example, the component is defined with clear types:

- `MyComponentProps`: Explicitly defines the expected props.
- `JSX.Element`: Specifies the component's return type.

This approach gives you precise control over the component's props and return
type, making your code more predictable and easier to maintain.

## Naming Conventions

- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for components.
- Use the name of the main componenent as name for the file, using upper camel case. Ex: Header.tsx for Header
  component. Avoid to use index.tsx, except if it's a collection of exported components (usually for packages lib in
  monorepo)

## TypeScript Usage

- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use maps instead.
- Use functional components with TypeScript interfaces.

## Syntax and Formatting

- Use the "function" keyword for pure functions.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple
  statements.
- Write declarative TSX.
- Almost never export default the component. Always use named export. The exception is when configuring a tool.

## UI and Styling

- Use Tailwind CSS and DaisyUI for component styling.
- Implement responsive design with Tailwind CSS; adopt a mobile-first approach.
- avoid margins for spacing in a lists or collection of items. Use gaps. Use margins only to place a high level
  component into another one, rarely between two "small" component like buttons.
- with tailwing avoid at maximum to use colors, like bg-red-500. It should be one of the primary, secondary ...

- Primary: main action and UI position
- Secondary: brand color, aka violet for Robusta
    - rarely second possible action
- Accent: CTA
- Neutral:  cancel, close
- base:

## Creation of a component

When creating a component, think of the Props interface first.
A component should expose what the user is interacting with, not the internal details of the component.

- Think first of the utility
- write the Props as an interface
- Make sure the component interface is testable

## Performance Optimization

- Optimize React performance by minimizing unnecessary re-renders and reducing
  heavy client-side state management.
- Use dynamic loading for non-critical components.
- Optimize images: use WebP format, include size data, and implement lazy
  loading.

## Key Conventions

- Use 'nuqs' for URL search parameter state management.
- Optimize Web Vitals (LCP, CLS, FID).
- Use ReactElement instead of JSX.Element

## Apply extra style to a component

When a component is not trivial, it usually makes sense to add some extraClasses to it.

The right way is this one:
twCss is exported in the file [merge-css.ts](mdc:libs/styles/merge-css.ts)

```tsx
interface TitleLinkProps {
  children: string;
  href: string;
  extraClasses?: string;
}
export function TitleLink  ({ children, href, extraClasses }: TitleLinkProps){
  return (
    <SimpleLink
      href={href}
      className={twCss(
        'text-primary font-bold ',
        extraClasses,
      )}
    >
      {children}
    </SimpleLink>
  );
};
```

## Daisy UI

Almost never add additional colors. Always refer to the daisy UI theme:

- Primary: main action and UI position
- Secondary: brand color, aka violet for Robusta
    - rarely second possible action
- Accent: CTA
- Neutral:  cancel, close
- base:
  'base-100': '#FFFFFF', white
  'base-200': '#F3F4F6', light grey
  'base-300': '#CCCCCC', grey

It's important to match the text content with the component color. So a btn-primary goes with text-primary-content

```tsx
<div className="bg-base-200 text-base-content">text base content</div>

<button className="btn btn-primary text-primary-content">Button with primary-content text</div>

```

For this project, here are the refference colors:

    primary: '#921514',
    secondary: '#00F4CF',
    accent: '#02284c',
    'accent-content': '#FFFFFF',
    'base-100': '#FFFFFF',
    'base-200': '#F3F4F6',
    'base-300': '#CCCCCC',

## When working on responsive design:

Tailwind has sm, md, lg, xl, 2xl breakpoints.
We will use mostly sm and lg, you can ignore md, xl and 2xl. Sometime I will add those manually, don't erase them except
if expressed.

But most importantly, you will prefer to use my tab breakpoint, which is sm in reverse:

In [tailwind.config.js](mdc:tailwind.config.js), I added mob - which stands for mobile

```  
  screens: {
      mob: { max: defaultTheme.screens.md },
      ...defaultTheme.screens,
    },
```

and `mob` can be used like this:

We hide if it's a mobile display

```
<div className={'mob:hidden flex justify-start gap-8'}>
....
</div>
```

Or : we display as columns

```
<ul className="mob:flex-col flex>...</ul>
```


